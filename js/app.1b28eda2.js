(function(e){function r(r){for(var t,o,s=r[0],c=r[1],l=r[2],d=0,u=[];d<s.length;d++)o=s[d],a[o]&&u.push(a[o][0]),a[o]=0;for(t in c)Object.prototype.hasOwnProperty.call(c,t)&&(e[t]=c[t]);h&&h(r);while(u.length)u.shift()();return i.push.apply(i,l||[]),n()}function n(){for(var e,r=0;r<i.length;r++){for(var n=i[r],t=!0,s=1;s<n.length;s++){var c=n[s];0!==a[c]&&(t=!1)}t&&(i.splice(r--,1),e=o(o.s=n[0]))}return e}var t={},a={app:0},i=[];function o(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=e,o.c=t,o.d=function(e,r,n){o.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,r){if(1&r&&(e=o(e)),8&r)return e;if(4&r&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var t in e)o.d(n,t,function(r){return e[r]}.bind(null,t));return n},o.n=function(e){var r=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(r,"a",r),r},o.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=r,s=s.slice();for(var l=0;l<s.length;l++)r(s[l]);var h=c;i.push([0,"chunk-vendors"]),n()})({0:function(e,r,n){e.exports=n("4188")},"5b61":function(e,r,n){},bcd5:function(e,r,n){"use strict";var t=function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("div",{attrs:{id:"app"}},[n("canvas",{attrs:{id:"cvs",width:e.w,height:e.h},on:{touchstart:function(e){e.preventDefault()},touchmove:e.handleTouchMove,mousemove:e.handleMouseMove}}),n("h2",[e._v("A demo for movable camera and path tracing")]),n("p",[e._v("How to play on PC or Mac")]),e._m(0),n("p",[e._v("How to play on mobile devices")]),e._m(1)])},a=[function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ul",[n("li",[e._v("move mouse inside to look around")]),n("li",[e._v("use WSAD key to walk around")])])},function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ul",[n("li",[e._v("touch and move inside to look around")]),n("li",[e._v("use two-finger gesture inside to walk around")])])}],i=(n("4081"),[-1,-1,1,-1,-1,1,1,1,-1,1,1,-1]);function o(e,r,n){var t=r,a=n,i=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(i,t),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS))return console.error("An error occurred compiling the vertex shaders: "+e.getShaderInfoLog(i)),e.deleteShader(i),null;var o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,a),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))return console.error("An error occurred compiling the fragment shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null;var s=e.createProgram();return e.attachShader(s,i),e.attachShader(s,o),e.linkProgram(s),s}var s={data:function(){return{w:512,h:512,mouse:{x:0,y:0},canvas:{left:0,top:0},cameraPos:{x:0,y:0,z:6},cameraDir:{yaw:0,pitch:0,x:0,y:0,z:-1},sampleCount:0}},mounted:function(){var e=this,r=document.querySelector("canvas").getBoundingClientRect();this.canvas.left=r.left,this.canvas.top=r.top,document.addEventListener("keypress",function(r){e.handleKeyPress(r)});var n=document.querySelector("#cvs").getContext("webgl"),t=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,t);var a=new Float32Array(i);n.bufferData(n.ARRAY_BUFFER,a,n.STATIC_DRAW);for(var s=[],c=0;c<2;c++)s.push(n.createTexture()),n.bindTexture(n.TEXTURE_2D,s[c]),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texImage2D(n.TEXTURE_2D,0,n.RGB,this.w,this.h,0,n.RGB,n.UNSIGNED_BYTE,null);var l=n.createFramebuffer(),h=o(n,"\n        attribute vec4 aPosition;\n        varying vec2 texCoord;\n\n        void main() {\n          texCoord = aPosition.xy * 0.5 + 0.5;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        varying vec2 texCoord;\n        uniform sampler2D tex;\n\n        void main() {\n          gl_FragColor = texture2D(tex, texCoord);\n        }\n      "),d=o(n,"\n        attribute vec4 aPosition;\n        varying vec4 vPosition;\n\n        void main() {\n          vPosition = aPosition;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        uniform vec2 u_resolution;\n        uniform vec2 u_mouse;\n        uniform vec3 u_camera_pos;\n        uniform vec3 u_camera_dir;\n        varying vec4 vPosition;\n        uniform float u_time;\n        uniform float u_sw;\n        uniform sampler2D tex;\n\n        // sphere center\n        const vec3 sc0 = vec3(-0.8,-0.5,-4.);\n        // sphere radius\n        const float sr0 = 0.5;\n        // sphere diffuse color\n        const vec3 sd0 = vec3(1.,0.3,0.3);\n\n        const vec3 sc1 = vec3(0.8,-0.5,-4.);\n        const float sr1 = 0.5;\n        const vec3 sd1 = vec3(0.84,0.55,0.15);\n\n\n        const vec3 sc2 = vec3(0.0,-0.4,-3.);\n        const float sr2 = 0.6;\n        const vec3 sd2 = vec3(1.,1.,1.);\n\n\n        // sky (a big sphere at the back of the scene)\n        const vec3 sc3 = vec3(0.,-0.5,-115.4);\n        const float sr3 = 100.0;\n        const vec3 sd3 = vec3(0.2,0.4,0.4);\n\n\n        // ground (a big sphere at the bottom of the scene)\n        const vec3 sc4 = vec3(0.,-101.,-4.);\n        const float sr4 = 100.0;\n        const vec3 sd4 = vec3(0.3,0.2,0.1);\n\n\n        float random(vec2 scale, float seed) {\n          return fract(sin(dot(gl_FragCoord.xy + seed, scale)) * 43758.5453);\n        }\n\n        vec3 cosineWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float r = sqrt(1. - v);\n          float x = r * cos(theta);\n          float y = sqrt(v);\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = normalize(cross(right, normal));\n          return right * x + normal * y + front * z;\n        }\n\n        vec3 customWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float k = pow(v, 0.0001);\n          float r = sqrt(1. - k*k);\n          float x = r * cos(theta);\n          float y = k;\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = normalize(cross(right, normal));\n          return right * x + normal * y + front * z;\n        }\n\n        // the function for ray-sphere intersection, given the origin and direction of a ray and the center and radius of a sphere\n        // returns the minimal distance when the ray hits the surface of the sphere\n        // when no intersection, returns 10000.0 \n        float sphere_hit(vec3 ro, vec3 rd, vec3 center, float r) {\n          vec3 oc = ro - center;\n          float a = dot(rd, rd);\n          float b = 2.0 * dot(oc, rd);\n          float c = dot(oc, oc) - r * r;\n          float discriminant = b * b - 4.0 * a * c;\n          if (discriminant > 0.0) {\n            float temp = (- b - sqrt(discriminant)) / (2.0 * a);\n            if (temp > 0.) {\n              return temp;\n            }\n          }\n          return 10000.0;\n        }\n\n        // the function for resolving color on a specific hit point\n        // currently returns only the diffuse color\n        vec3 calc_color(vec3 hit, vec3 normal, vec3 diff_c) {\n          vec3 light = vec3(2.8,2.5,1.5);\n          vec3 l = normalize(light - hit);\n          float diff = dot(l, normal);\n\n          vec3 v = normalize(u_camera_pos - hit);\n          float spec = dot(v, reflect(-l, normal));\n          return pow(max(diff, 0.), 4.) + pow(max(spec,0.), 32.) + diff_c;\n        }\n\n        vec3 refr(vec3 ray, vec3 normal, float ri) {\n          float dt = dot(ray, normal);\n          float ni_over_nt;\n          vec3 n;\n          if (dt > 0.) {\n            n = -normal;\n            ni_over_nt = ri;\n          } else {\n            n = normal;\n            ni_over_nt = 1./ri;\n          }\n\n          float discriminant = 1. - ni_over_nt*ni_over_nt*(1. - dt*dt);\n          if (discriminant > 0.) {\n            return ri*(ray - n*dt)-n*sqrt(discriminant);\n          } else {\n            return reflect(ray, normal);\n          }\n        }\n\n        vec4 trace(vec3 ro, vec3 rd) {\n          vec3 color_mask = vec3(1.);\n          vec3 accu_color = vec3(1.);\n\n          // the path tracing depth\n          for (int i = 0; i < 5; i++) {\n            // finding the nearest hit point by checking intersection with every spheres\n            float dist = 10000.0;\n            float d0 = sphere_hit(ro, rd,sc0, sr0);\n            float d1 = sphere_hit(ro, rd,sc1, sr1);\n            float d2 = sphere_hit(ro, rd,sc2, sr2);\n            float d3 = sphere_hit(ro, rd,sc3, sr3);\n            float d4 = sphere_hit(ro, rd,sc4, sr4);\n\n            if (dist > d0) dist = d0;\n            if (dist > d1) dist = d1;\n            if (dist > d2) dist = d2;\n            if (dist > d3) dist = d3;\n            if (dist > d4) dist = d4;\n\n            vec3 hit = ro + dist * rd;\n            vec3 normal;\n            vec3 diffuse;\n\n            if (dist == 10000.0) {\n              break;\n            // if any sphere is hit, accumulate the color on the sphere,\n            // and find a randomly scattered ray from the hit point as new ray\n            // for the next loop of path tracing\n            } else if (dist == d0) {\n              diffuse = sd0;\n              normal = normalize(hit - sc0);\n            } else if (dist == d1) {\n              diffuse = sd1;\n              normal = normalize(hit - sc1);\n            } else if (dist == d2) {\n              diffuse = sd2;\n              normal = normalize(hit - sc2);\n            } else if (dist == d3) {\n              diffuse = sd3;\n              normal = normalize(hit - sc3);\n            } else if (dist == d4) {\n              diffuse = sd4;\n              normal = normalize(hit - sc4);\n            }\n            color_mask *= diffuse;\n\n            if (dist == d0) {\n              rd = customWeightedDirection(u_time, reflect(rd, normal));\n            } else if (dist == d2) {\n              rd = customWeightedDirection(u_time,refr(rd, normal, 1.2));\n            } else {\n              rd = cosineWeightedDirection(u_time, normal);\n            }\n\n            accu_color *= calc_color(hit, normal, color_mask);\n            ro = hit - 0.001 * normal;\n          }\n          return vec4(accu_color, 1.);\n        }\n\n        const float screen_dist = 6.;\n\n        void main() {\n          // s,t is the x,y axis of the screen-space coordinate,\n          // first assuming that there is a screen that lies in the world-space with its center at (0,0,0)\n          // and the plane of screen is parallel to the xy plane\n          vec3 st = vec3(vPosition.xy, 0.);\n          st.x = st.x * u_resolution.x / u_resolution.y;\n          st.y = -st.y;\n\n          // then, convert the screen to world-space where a camera position and direction is determined\n          // this is done by an inverse matrix operation of gluLookAt\n          // first change the basis, then translate to the world-space\n\n          vec3 screen_origin = u_camera_pos + screen_dist * u_camera_dir;\n          vec3 v = normalize(u_camera_dir);\n          vec3 up = vec3(0.,1.,0.);\n          vec3 r = normalize(cross(v,up));\n          vec3 u = normalize(cross(v,r));\n          \n          mat4 basis = mat4(\n            r.x,r.y,r.z,0.,\n            u.x,u.y,u.z,0.,\n            v.x,v.y,v.z,0.,\n            0.,0.,0.,1.\n          );\n\n          mat4 translate = mat4(\n            1.,0.,0.,0.,\n            0.,1.,0.,0.,\n            0.,0.,1.,0.,\n            screen_origin.x,screen_origin.y,screen_origin.z,1.\n          );\n\n          mat4 view = translate * basis;\n          vec4 str = vec4(st,1.);\n          str = view * str;\n\n          vec3 rd = normalize(str.xyz - u_camera_pos);\n          vec3 ro = u_camera_pos;\n          vec4 result = trace(ro, rd);\n          \n          // gamma correction\n          result.x = sqrt(result.x);\n          result.y = sqrt(result.y);\n          result.z = sqrt(result.z);\n          // progressive rendering, where the results is accumulated with previous frame render result\n          // u_sw is a value that approximates 1\n          // thus the new frame will contribute less to the final image as time elapses\n          vec3 prev = texture2D(tex, gl_FragCoord.xy/512.0).rgb;\n          gl_FragColor = vec4(mix(result.rgb, prev, u_sw), 1.);\n        }\n      "),u=0,m=0,f=this.w,v=this.h,p=this;function _(e){e||(e=0),e*=.05;var r=e-m;m=e,n.clearColor(0,0,0,0),n.bindBuffer(n.ARRAY_BUFFER,t),n.linkProgram(d),n.useProgram(d),n.vertexAttribPointer(0,2,n.FLOAT,!1,8,0),n.enableVertexAttribArray(0),n.bindAttribLocation(d,0,"aPosition"),u+=r,p.sampleCount++;var a=n.getUniformLocation(d,"u_time");n.uniform1f(a,u);var i=n.getUniformLocation(d,"u_sw");n.uniform1f(i,p.sampleCount/(p.sampleCount+1));var o=n.getUniformLocation(d,"u_mouse");n.uniform2f(o,p.mouse.x,p.mouse.y);var c=n.getUniformLocation(d,"u_resolution");n.uniform2f(c,f,v);var g=n.getUniformLocation(d,"u_camera_pos");n.uniform3f(g,p.cameraPos.x,p.cameraPos.y,p.cameraPos.z);var y=n.getUniformLocation(d,"u_camera_dir");n.uniform3f(y,p.cameraDir.x,p.cameraDir.y,p.cameraDir.z),n.bindTexture(n.TEXTURE_2D,s[0]),n.bindFramebuffer(n.FRAMEBUFFER,l),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s[1],0),n.drawArrays(n.TRIANGLES,0,6),n.bindFramebuffer(n.FRAMEBUFFER,null),s.reverse(),n.useProgram(h),n.bindTexture(n.TEXTURE_2D,s[0]),n.vertexAttribPointer(0,2,n.FLOAT,!1,8,0),n.enableVertexAttribArray(0),n.bindAttribLocation(d,0,"aPosition"),n.drawArrays(n.TRIANGLES,0,6),window.requestAnimationFrame(function(e){return _(e)})}window.requestAnimationFrame(function(e){return _(e)})},methods:{crossProduct:function(e,r,n,t,a,i){return[r*i-n*a,n*t-e*t,e*a-r*t]},degToRad:function(e){return 3.14159*e/180},handleLeftRight:function(e){var r=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=e*r[0],this.cameraPos.y-=e*r[1],this.cameraPos.z-=e*r[2]},handleForwardBackward:function(e){this.cameraPos.x+=e*this.cameraDir.x,this.cameraPos.y+=e*this.cameraDir.y,this.cameraPos.z+=e*this.cameraDir.z},handleKeyPress:function(e){this.sampleCount=0;var r=e.key,n=.1;if("w"===r)this.cameraPos.x+=n*this.cameraDir.x,this.cameraPos.y+=n*this.cameraDir.y,this.cameraPos.z+=n*this.cameraDir.z;else if("s"===r)this.cameraPos.x-=n*this.cameraDir.x,this.cameraPos.y-=n*this.cameraDir.y,this.cameraPos.z-=n*this.cameraDir.z;else if("a"===r){var t=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=n*t[0],this.cameraPos.y-=n*t[1],this.cameraPos.z-=n*t[2]}else if("d"===r){var a=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x+=n*a[0],this.cameraPos.y+=n*a[1],this.cameraPos.z+=n*a[2]}},handleMouseMove:function(e){e.preventDefault(),this.sampleCount=0;var r=(e.clientX-this.canvas.left)/this.w-.5,n=(e.clientY-this.canvas.top)/this.h-.5;n=-n,r*=360,r=this.degToRad(r),n*=180,n=this.degToRad(n),this.cameraDir.pitch=n,this.cameraDir.yaw=r,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw)},handleTouchMove:function(e){e.preventDefault(),this.sampleCount=0;var r=(e.touches[0].clientX-this.canvas.left)/this.w-.5,n=(e.touches[0].clientY-this.canvas.top)/this.h-.5;n=-n,2===e.touches.length?(this.handleLeftRight(-.05*r),this.handleForwardBackward(.05*n)):(r*=360,r=this.degToRad(r),n*=180,n=this.degToRad(n),this.cameraDir.pitch+=.002*n,this.cameraDir.yaw+=.002*r,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw))}}},c=s,l=(n("e5cd"),n("09fd")),h=Object(l["a"])(c,t,a,!1,null,null,null);r["a"]=h.exports},e5cd:function(e,r,n){"use strict";var t=n("5b61"),a=n.n(t);a.a}});
//# sourceMappingURL=app.1b28eda2.js.map