(function(e){function r(r){for(var n,o,s=r[0],c=r[1],h=r[2],u=0,d=[];u<s.length;u++)o=s[u],a[o]&&d.push(a[o][0]),a[o]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);l&&l(r);while(d.length)d.shift()();return i.push.apply(i,h||[]),t()}function t(){for(var e,r=0;r<i.length;r++){for(var t=i[r],n=!0,s=1;s<t.length;s++){var c=t[s];0!==a[c]&&(n=!1)}n&&(i.splice(r--,1),e=o(o.s=t[0]))}return e}var n={},a={app:0},i=[];function o(r){if(n[r])return n[r].exports;var t=n[r]={i:r,l:!1,exports:{}};return e[r].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=e,o.c=n,o.d=function(e,r,t){o.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,r){if(1&r&&(e=o(e)),8&r)return e;if(4&r&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)o.d(t,n,function(r){return e[r]}.bind(null,n));return t},o.n=function(e){var r=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(r,"a",r),r},o.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=r,s=s.slice();for(var h=0;h<s.length;h++)r(s[h]);var l=c;i.push([0,"chunk-vendors"]),t()})({0:function(e,r,t){e.exports=t("4188")},"5b61":function(e,r,t){},bcd5:function(e,r,t){"use strict";var n=function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{attrs:{id:"app"}},[t("canvas",{attrs:{id:"cvs",width:e.w,height:e.h},on:{touchstart:function(e){e.preventDefault()},touchmove:e.handleTouchMove,mousemove:e.handleMouseMove}}),t("h2",[e._v("A demo for movable camera and path tracing")]),t("p",[e._v("How to play on PC or Mac")]),e._m(0),t("p",[e._v("How to play on mobile devices")]),e._m(1)])},a=[function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ul",[t("li",[e._v("move mouse inside to look around")]),t("li",[e._v("use WSAD key to walk around")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ul",[t("li",[e._v("touch and move inside to look around")]),t("li",[e._v("use two-finger gesture inside to walk around")])])}],i=(t("4081"),[-1,-1,1,-1,-1,1,1,1,-1,1,1,-1]);function o(e,r,t){var n=r,a=t,i=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(i,n),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS))return console.error("An error occurred compiling the vertex shaders: "+e.getShaderInfoLog(i)),e.deleteShader(i),null;var o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,a),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))return console.error("An error occurred compiling the fragment shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null;var s=e.createProgram();return e.attachShader(s,i),e.attachShader(s,o),e.linkProgram(s),s}var s={data:function(){return{w:512,h:512,mouse:{x:0,y:0},canvas:{left:0,top:0},cameraPos:{x:0,y:0,z:6},cameraDir:{yaw:0,pitch:0,x:0,y:0,z:-1},sampleCount:0}},mounted:function(){var e=this,r=document.querySelector("canvas").getBoundingClientRect();this.canvas.left=r.left,this.canvas.top=r.top,document.addEventListener("keypress",function(r){e.handleKeyPress(r)});var t=document.querySelector("#cvs").getContext("webgl"),n=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,n);var a=new Float32Array(i);t.bufferData(t.ARRAY_BUFFER,a,t.STATIC_DRAW);for(var s=[],c=0;c<2;c++)s.push(t.createTexture()),t.bindTexture(t.TEXTURE_2D,s[c]),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texImage2D(t.TEXTURE_2D,0,t.RGB,this.w,this.h,0,t.RGB,t.UNSIGNED_BYTE,null);var h=t.createFramebuffer(),l=o(t,"\n        attribute vec4 aPosition;\n        varying vec2 texCoord;\n\n        void main() {\n          texCoord = aPosition.xy * 0.5 + 0.5;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        varying vec2 texCoord;\n        uniform sampler2D tex;\n\n        void main() {\n          gl_FragColor = texture2D(tex, texCoord);\n        }\n      "),u=o(t,"\n        attribute vec4 aPosition;\n        varying vec4 vPosition;\n\n        void main() {\n          vPosition = aPosition;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        uniform vec2 u_resolution;\n        uniform vec2 u_mouse;\n        uniform vec3 u_camera_pos;\n        uniform vec3 u_camera_dir;\n        varying vec4 vPosition;\n        uniform float u_time;\n        uniform float u_sw;\n        uniform sampler2D tex;\n\n        const vec3 sc0 = vec3(-0.8,0.,-4.);\n        const float sr0 = 0.4;\n        const vec3 sc1 = vec3(0.,0.,-4.);\n        const float sr1 = 0.4;\n        const vec3 sc2 = vec3(0.8,0.,-4.);\n        const float sr2 = 0.4;\n        // sky (a big sphere at the back of the scene)\n        const vec3 sc3 = vec3(0.,0.,-104.4);\n        const float sr3 = 100.0;\n        // ground (a big sphere at the bottom of the scene)\n        const vec3 sc4 = vec3(0.,-100.4,-4.);\n        const float sr4 = 100.0;\n        // light (a sphere with an intentially overflowed color (brighter than vec3(1.,1.,1.)))\n        const vec3 sc5 = vec3(0.8,0.5,-3.5);\n        const float sr5 = 0.15;\n\n        // code from https://github.com/evanw/webgl-path-tracing/blob/master/webgl-path-tracing.js\n        float random(vec3 scale, float seed) {\n          return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n        }\n\n        vec3 cosineWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n          float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n          float r = sqrt(u);\n          float angle = 6.283185307179586 * v;\n          vec3 sdir, tdir;\n          if (abs(normal.x)<.5) {\n            sdir = cross(normal, vec3(1,0,0));\n          } else {\n            sdir = cross(normal, vec3(0,1,0));\n          }\n          tdir = cross(normal, sdir);\n          return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;\n        }\n\n        // the function for ray-sphere intersection, given the origin and direction of a ray and the center and radius of a sphere\n        // returns the minimal distance when the ray hits the surface of the sphere\n        // when no intersection, returns 10000.0 \n        float sphere_hit(vec3 ro, vec3 rd, vec3 center, float r) {\n          vec3 oc = ro - center;\n          float a = dot(rd, rd);\n          float b = 2.0 * dot(oc, rd);\n          float c = dot(oc, oc) - r * r;\n          float discriminant = b * b - 4.0 * a * c;\n          if (discriminant > 0.0) {\n            float temp = (- b - sqrt(discriminant)) / (2.0 * a);\n            if (temp > 0.) {\n              return temp;\n            }\n          }\n          return 10000.0;\n        }\n\n        // the function for resolving color on a specific hit point\n        // currently returns only the diffuse color\n        vec3 calc_color(vec3 hit, vec3 normal, vec3 diff_c) {\n          vec3 light = vec3(0.8,0.5,-3.5);\n          vec3 l = normalize(light - hit);\n          float diff = dot(l, normal);\n\n          vec3 v = normalize(u_camera_pos - hit);\n          float spec = dot(v, reflect(-l, normal));\n          return pow(max(diff, 0.), 4.) + pow(max(spec,0.), 32.) + diff_c;\n        }\n\n        vec4 trace(vec3 ro, vec3 rd) {\n          vec3 color_mask = vec3(1.);\n          vec3 accu_color = vec3(1.);\n\n          // the path tracing depth\n          for (int i = 0; i < 5; i++) {\n            // finding the nearest hit point by checking intersection with every spheres\n            float dist = 10000.0;\n            float d0 = sphere_hit(ro, rd,sc0, sr0);\n            float d1 = sphere_hit(ro, rd,sc1, sr1);\n            float d2 = sphere_hit(ro, rd,sc2, sr2);\n            float d3 = sphere_hit(ro, rd,sc3, sr3);\n            float d4 = sphere_hit(ro, rd,sc4, sr4);\n\n            if (dist > d0) dist = d0;\n            if (dist > d1) dist = d1;\n            if (dist > d2) dist = d2;\n            if (dist > d3) dist = d3;\n            if (dist > d4) dist = d4;\n\n            vec3 hit = ro + dist * rd;\n            vec3 normal;\n            vec3 diffuse;\n\n            if (dist == 10000.0) {\n              break;\n            // if any sphere is hit, accumulate the color on the sphere,\n            // and find a randomly scattered ray from the hit point as new ray\n            // for the next loop of path tracing\n            } else if (dist == d0) {\n              diffuse = vec3(1.,0.3,0.3);\n              normal = normalize(hit - sc0);\n            } else if (dist == d1) {\n              diffuse = vec3(1.,1.,1.);\n              normal = normalize(hit - sc1);\n            } else if (dist == d2) {\n              diffuse = vec3(0.3,0.3,1.);\n              normal = normalize(hit - sc2);\n            } else if (dist == d3) {\n              diffuse = vec3(0.2,0.4,0.4);\n              normal = normalize(hit - sc3);\n            } else if (dist == d4) {\n              diffuse = vec3(0.3,0.2,0.1);\n              normal = normalize(hit - sc4);\n            }\n            color_mask *= diffuse;\n            rd = cosineWeightedDirection(u_time+float(i), normal);\n\n            accu_color *= calc_color(hit, normal, color_mask);\n            ro = hit;\n          }\n          return vec4(accu_color, 1.);\n        }\n\n        const float screen_dist = 6.;\n\n        void main() {\n          // s,t is the x,y axis of the screen-space coordinate,\n          // first assuming that there is a screen that lies in the world-space with its center at (0,0,0)\n          // and the plane of screen is parallel to the xy plane\n          vec3 st = vec3(vPosition.xy, 0.);\n          st.x = st.x * u_resolution.x / u_resolution.y;\n          st.y = -st.y;\n\n          // then, convert the screen to world-space where a camera position and direction is determined\n          // this is done by an inverse matrix operation of gluLookAt\n          // first change the basis, then translate to the world-space\n\n          vec3 screen_origin = u_camera_pos + screen_dist * u_camera_dir;\n          vec3 v = normalize(u_camera_dir);\n          vec3 up = vec3(0.,1.,0.);\n          vec3 r = normalize(cross(v,up));\n          vec3 u = normalize(cross(v,r));\n          \n          mat4 basis = mat4(\n            r.x,r.y,r.z,0.,\n            u.x,u.y,u.z,0.,\n            v.x,v.y,v.z,0.,\n            0.,0.,0.,1.\n          );\n\n          mat4 translate = mat4(\n            1.,0.,0.,0.,\n            0.,1.,0.,0.,\n            0.,0.,1.,0.,\n            screen_origin.x,screen_origin.y,screen_origin.z,1.\n          );\n\n          mat4 view = translate * basis;\n          vec4 str = vec4(st,1.);\n          str = view * str;\n\n          vec3 rd = normalize(str.xyz - u_camera_pos);\n          vec3 ro = u_camera_pos;\n          vec4 result = trace(ro, rd);\n          \n          // gamma correction\n          result.x = sqrt(result.x);\n          result.y = sqrt(result.y);\n          result.z = sqrt(result.z);\n          // progressive rendering, where the results is accumulated with previous frame render result\n          // u_sw is a value that approximates 1\n          // thus the new frame will contribute less to the final image as time elapses\n          vec3 prev = texture2D(tex, gl_FragCoord.xy/512.0).rgb;\n          gl_FragColor = vec4(mix(result.rgb, prev, u_sw), 1.);\n        }\n      "),d=0,m=0,f=this.w,v=this.h,p=this;function _(e){e||(e=0),e*=.05;var r=e-m;m=e,t.clearColor(0,0,0,0),t.bindBuffer(t.ARRAY_BUFFER,n),t.linkProgram(u),t.useProgram(u),t.vertexAttribPointer(0,2,t.FLOAT,!1,8,0),t.enableVertexAttribArray(0),t.bindAttribLocation(u,0,"aPosition"),d+=r,p.sampleCount++;var a=t.getUniformLocation(u,"u_time");t.uniform1f(a,d);var i=t.getUniformLocation(u,"u_sw");t.uniform1f(i,p.sampleCount/(p.sampleCount+1));var o=t.getUniformLocation(u,"u_mouse");t.uniform2f(o,p.mouse.x,p.mouse.y);var c=t.getUniformLocation(u,"u_resolution");t.uniform2f(c,f,v);var g=t.getUniformLocation(u,"u_camera_pos");t.uniform3f(g,p.cameraPos.x,p.cameraPos.y,p.cameraPos.z);var y=t.getUniformLocation(u,"u_camera_dir");t.uniform3f(y,p.cameraDir.x,p.cameraDir.y,p.cameraDir.z),t.bindTexture(t.TEXTURE_2D,s[0]),t.bindFramebuffer(t.FRAMEBUFFER,h),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s[1],0),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),s.reverse(),t.useProgram(l),t.bindTexture(t.TEXTURE_2D,s[0]),t.vertexAttribPointer(0,2,t.FLOAT,!1,8,0),t.enableVertexAttribArray(0),t.bindAttribLocation(u,0,"aPosition"),t.drawArrays(t.TRIANGLES,0,6),window.requestAnimationFrame(function(e){return _(e)})}window.requestAnimationFrame(function(e){return _(e)})},methods:{crossProduct:function(e,r,t,n,a,i){return[r*i-t*a,t*n-e*n,e*a-r*n]},degToRad:function(e){return 3.14159*e/180},handleLeftRight:function(e){var r=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=e*r[0],this.cameraPos.y-=e*r[1],this.cameraPos.z-=e*r[2]},handleForwardBackward:function(e){this.cameraPos.x+=e*this.cameraDir.x,this.cameraPos.y+=e*this.cameraDir.y,this.cameraPos.z+=e*this.cameraDir.z},handleKeyPress:function(e){this.sampleCount=0;var r=e.key,t=.1;if("w"===r)this.cameraPos.x+=t*this.cameraDir.x,this.cameraPos.y+=t*this.cameraDir.y,this.cameraPos.z+=t*this.cameraDir.z;else if("s"===r)this.cameraPos.x-=t*this.cameraDir.x,this.cameraPos.y-=t*this.cameraDir.y,this.cameraPos.z-=t*this.cameraDir.z;else if("a"===r){var n=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=t*n[0],this.cameraPos.y-=t*n[1],this.cameraPos.z-=t*n[2]}else if("d"===r){var a=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x+=t*a[0],this.cameraPos.y+=t*a[1],this.cameraPos.z+=t*a[2]}},handleMouseMove:function(e){e.preventDefault(),this.sampleCount=0;var r=(e.clientX-this.canvas.left)/this.w-.5,t=(e.clientY-this.canvas.top)/this.h-.5;t=-t,r*=360,r=this.degToRad(r),t*=180,t=this.degToRad(t),this.cameraDir.pitch=t,this.cameraDir.yaw=r,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw)},handleTouchMove:function(e){e.preventDefault(),this.sampleCount=0;var r=(e.touches[0].clientX-this.canvas.left)/this.w-.5,t=(e.touches[0].clientY-this.canvas.top)/this.h-.5;t=-t,2===e.touches.length?(this.handleLeftRight(-.05*r),this.handleForwardBackward(.05*t)):(r*=360,r=this.degToRad(r),t*=180,t=this.degToRad(t),this.cameraDir.pitch+=.002*t,this.cameraDir.yaw+=.002*r,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw))}}},c=s,h=(t("e5cd"),t("09fd")),l=Object(h["a"])(c,n,a,!1,null,null,null);r["a"]=l.exports},e5cd:function(e,r,t){"use strict";var n=t("5b61"),a=t.n(n);a.a}});
//# sourceMappingURL=app.b2352650.js.map