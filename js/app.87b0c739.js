(function(e){function t(t){for(var n,o,c=t[0],s=t[1],h=t[2],l=0,m=[];l<c.length;l++)o=c[l],i[o]&&m.push(i[o][0]),i[o]=0;for(n in s)Object.prototype.hasOwnProperty.call(s,n)&&(e[n]=s[n]);d&&d(t);while(m.length)m.shift()();return a.push.apply(a,h||[]),r()}function r(){for(var e,t=0;t<a.length;t++){for(var r=a[t],n=!0,c=1;c<r.length;c++){var s=r[c];0!==i[s]&&(n=!1)}n&&(a.splice(t--,1),e=o(o.s=r[0]))}return e}var n={},i={app:0},a=[];function o(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,o),r.l=!0,r.exports}o.m=e,o.c=n,o.d=function(e,t,r){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(o.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)o.d(r,n,function(t){return e[t]}.bind(null,n));return r},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="/";var c=window["webpackJsonp"]=window["webpackJsonp"]||[],s=c.push.bind(c);c.push=t,c=c.slice();for(var h=0;h<c.length;h++)t(c[h]);var d=s;a.push([0,"chunk-vendors"]),r()})({0:function(e,t,r){e.exports=r("4188")},"5b61":function(e,t,r){},bcd5:function(e,t,r){"use strict";var n=function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{attrs:{id:"app"}},[r("canvas",{attrs:{id:"cvs",width:e.w,height:e.h},on:{touchstart:function(e){e.preventDefault()},touchmove:e.handleTouchMove,mousemove:e.handleMouseMove}}),r("h2",[e._v("A demo for movable camera and path tracing")]),r("span",[e._v("Select a camera mode: ")]),r("input",{directives:[{name:"model",rawName:"v-model",value:e.cameraMode,expression:"cameraMode"}],attrs:{type:"radio",id:"free",value:"free"},domProps:{checked:e._q(e.cameraMode,"free")},on:{change:function(t){e.cameraMode="free"}}}),r("label",{attrs:{for:"free"}},[e._v("free")]),r("input",{directives:[{name:"model",rawName:"v-model",value:e.cameraMode,expression:"cameraMode"}],attrs:{type:"radio",id:"focus",value:"focus"},domProps:{checked:e._q(e.cameraMode,"focus")},on:{change:function(t){e.cameraMode="focus"}}}),r("label",{attrs:{for:"focus"}},[e._v("focus")]),r("p",[e._v("TIP: On PC or Mac, use F to toggle camera mode")]),r("p",[r("button",{on:{click:e.showHowToPlay}},[e._v("How to play?")])])])},i=[],a=r("90a7"),o=(r("4081"),[-1,-1,1,-1,-1,1,1,1]);function c(e,t,r){var n=t,i=r,a=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(a,n),e.compileShader(a),!e.getShaderParameter(a,e.COMPILE_STATUS))return console.error("An error occurred compiling the vertex shaders: "+e.getShaderInfoLog(a)),e.deleteShader(a),null;var o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,i),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))return console.error("An error occurred compiling the fragment shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null;var c=e.createProgram();return e.attachShader(c,a),e.attachShader(c,o),e.linkProgram(c),c}var s={data:function(){return{cameraMode:"focus",w:512,h:512,mouse:{x:0,y:0},canvas:{left:0,top:0},screenDist:6,cameraPos:{x:0,y:0,z:6},cameraDir:{yaw:0,pitch:0,x:0,y:0,z:-1},screenOrigin:{x:0,y:0,z:0},sampleCount:0}},mounted:function(){var e=this,t=document.querySelector("canvas").getBoundingClientRect();this.canvas.left=t.left,this.canvas.top=t.top,document.addEventListener("keypress",function(t){e.handleKeyPress(t)});var r=document.querySelector("#cvs").getContext("webgl"),n=c(r,"\n        attribute vec4 aPosition;\n        varying vec4 vPosition;\n\n        void main() {\n          vPosition = aPosition;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        uniform vec3 u_camera_pos;\n        varying vec4 vPosition;\n        uniform float u_time;\n        uniform float u_sw;\n        uniform mat4 u_screen_to_world;\n        uniform sampler2D tex;\n\n        // cube min vertx\n        const vec3 cmin0 = vec3(-0.2,-1.0,-4.2);\n        // cube max vertx\n        const vec3 cmax0 = vec3(0.2,-0.6,-3.8);\n        // cube diffuse color\n        const vec3 cd0 = vec3(0.9);\n\n        // sphere center\n        const vec3 sc0 = vec3(-0.8,-0.8,-4.);\n        // sphere radius\n        const float sr0 = 0.2;\n        // sphere diffuse color\n        const vec3 sd0 = vec3(0.9);\n\n        // cylinder center\n        const vec3 cc0 = vec3(0.8, -0.7, -4.0);\n        // cylinder height\n        const float ch0 = 0.3;\n        // cylinder radius\n        const float cr0 = 0.3;\n\n        // y_triangle y value\n        const float ty0 = -0.95;\n\n        // y_triangle vertices\n        const vec2 tv00 = vec2(-0.5,-2.866);\n        const vec2 tv01 = vec2(0.5,-2.866);\n        const vec2 tv02 = vec2(0.,-2.);\n\n        // sky (a infinite plane at the back of the scene)\n        const float pz = -6.5;\n        const vec3 pzd = vec3(1.,0.5,0.5);\n\n        // ground (a infinite plane at the bottom of the scene)\n        const float py = -1.;\n        const vec3 pyd = vec3(0.78,0.95,0.84);\n\n\n        float random(vec2 scale, float seed) {\n          return fract(sin(dot(gl_FragCoord.xy + seed, scale)) * 43758.5453);\n        }\n\n        vec3 cosineWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float r = sqrt(1. - v);\n          float x = r * cos(theta);\n          float y = sqrt(v);\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = cross(right, normal);\n          return right * x + normal * y + front * z;\n        }\n\n        vec3 customWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float k = pow(v, 0.0001);\n          float r = sqrt(1. - k*k);\n          float x = r * cos(theta);\n          float y = k;\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = cross(right, normal);\n          return right * x + normal * y + front * z;\n        }\n\n        // the function for ray-sphere intersection, given the origin and direction of a ray and the center and radius of a sphere\n        // returns the minimal distance when the ray hits the surface of the sphere\n        // when no intersection, returns 10000.0 \n        float sphere_hit(vec3 ro, vec3 rd, vec3 center, float r) {\n          vec3 oc = ro - center;\n          float a = dot(rd, rd);\n          float b = 2.0 * dot(oc, rd);\n          float c = dot(oc, oc) - r * r;\n          float discriminant = b * b - 4.0 * a * c;\n          if (discriminant > 0.0) {\n            float temp = (- b - sqrt(discriminant)) / (2.0 * a);\n            if (temp > 0.) {\n              return temp;\n            }\n          }\n          return 10000.0;\n        }\n\n        // the function for axis-aligned ray-box intersection\n        vec2 box_hit(vec3 ro, vec3 rd, vec3 box_min, vec3 box_max) {\n          vec3 tmin = (box_min - ro) / rd;\n          vec3 tmax = (box_max - ro) / rd;\n\n          vec3 t1 = min(tmin, tmax);\n          vec3 t2 = max(tmin, tmax);\n\n          float tnear = max(max(t1.x, t1.y), t1.z);\n          float tfar = min(min(t2.x, t2.y), t2.z);\n\n          return vec2(tnear, tfar);\n        }\n\n        // the function for a z-axis perpendicular plane and ray intersection\n        float z_plane_hit(vec3 ro, vec3 rd, float z) {\n          return (z - ro.z) / rd.z;\n        }\n\n        // the function for a y-axis perpendicular plane and ray intersection\n        float y_plane_hit(vec3 ro, vec3 rd, float y) {\n          return (y - ro.y) / rd.y;\n        }\n\n        // the function for a y-axis perpendicular disk (circle shaped plane) and ray intersection\n        float y_disk_hit(vec3 ro, vec3 rd, vec3 center, float r) {\n          float t = y_plane_hit(ro, rd, center.y);\n          if (t > 0.) {\n            vec3 hit = ro + t * rd;\n            if (length(center - hit) < r) {\n              return t;\n            }\n          }\n          return 10000.0;\n        }\n\n        // the function for ray-cylinder intersection\n        float cylinder_hit(vec3 ro, vec3 rd, vec3 center, float h, float r, out int face) {\n          vec2 oc = (ro - center).xz;\n          vec2 rd2 = rd.xz;\n          float a = dot(rd2, rd2);\n          float b = 2.0 * dot(oc, rd2);\n          float c = dot(oc, oc) - r * r;\n          float discriminant = b * b - 4.0 * a * c;\n          float top = center.y + h;\n          float bottom = center.y - h;\n\n          float temp = (- b - sqrt(discriminant)) / (2.0 * a);\n          vec3 hit = ro + temp * rd;\n          if (temp > 0. && hit.y < top && hit.y > bottom) {\n            face = 0;\n            return temp;\n          } else if (hit.y > top) {\n            face = 1;\n            return y_disk_hit(ro, rd, center + vec3(0.,h,0.), r);\n          } else {\n            face = 2;\n            return y_disk_hit(ro, rd, center + vec3(0.,-h, 0.), r);\n          }\n\n          return 10000.0;\n        }\n\n        float det2x2(vec2 va, vec2 vb) {\n          return (va.x * vb.y) - (vb.x * va.y);\n        }\n\n        bool in_triangle(vec2 p, vec2 v1, vec2 v2, vec2 v3) {\n          float d1 = det2x2(v2 - v1,p - v1);\n          float d2 = det2x2(v3 - v2,p - v2);\n          float d3 = det2x2(v1 - v3,p - v3);\n\n          return (\n            (d1 < 0. && d2 < 0. && d3 < 0.) ||\n            (d1 > 0. && d2 > 0. && d3 > 0.)\n          );\n        }\n\n        // the function for a y-axis perpendicula triangle and ray intersection\n        float y_triangle_hit(vec3 ro, vec3 rd, float y, vec2 v1, vec2 v2, vec2 v3) {\n          float t = y_plane_hit(ro, rd, y);\n          vec3 hit = ro + t * rd;\n          if (in_triangle(hit.xz, v1, v2, v3)) {\n            return t;\n          }\n          return 10000.0;\n        }\n\n        // the function for resolving color on a specific hit point\n        // currently returns only the diffuse color\n        vec3 calc_color(vec3 hit, vec3 normal, vec3 diff_c) {\n          vec3 light = vec3(2.8,2.5,1.5);\n          vec3 l = normalize(light - hit);\n          float diff = dot(l, normal);\n\n          vec3 v = normalize(u_camera_pos - hit);\n          float spec = dot(v, reflect(-l, normal));\n          return pow(max(diff, 0.), 4.) + pow(max(spec,0.), 32.) + diff_c;\n        }\n\n        vec3 refr(vec3 ray, vec3 normal, float ri) {\n          float dt = dot(ray, normal);\n          float ni_over_nt;\n          vec3 n;\n          if (dt > 0.) {\n            n = -normal;\n            ni_over_nt = ri;\n          } else {\n            n = normal;\n            ni_over_nt = 1./ri;\n          }\n\n          float discriminant = 1. - ni_over_nt*ni_over_nt*(1. - dt*dt);\n          if (discriminant > 0.) {\n            return ri*(ray - n*dt)-n*sqrt(discriminant);\n          } else {\n            return reflect(ray, normal);\n          }\n        }\n\n        vec3 box_normal(vec3 hit, vec3 box_min, vec3 box_max) {\n          if (hit.x < box_min.x + 0.001) return vec3(-1,0,0);\n          else if (hit.x > box_max.x - 0.001) return vec3(1,0,0);\n\n          else if (hit.y < box_min.y + 0.001) return vec3(0,-1,0);\n          else if (hit.y > box_max.y - 0.001) return vec3(0,1,0);\n\n          else if (hit.z < box_min.z + 0.001) return vec3(0,0,-1);\n          return vec3(0,0,1);\n        }\n\n        vec4 trace(vec3 ro, vec3 rd) {\n          vec3 color_mask = vec3(1.);\n          vec3 accu_color = vec3(1.);\n\n          int cylinder_face = -1;\n\n          // the path tracing depth\n          for (int i = 0; i < 5; i++) {\n            // finding the nearest hit point by checking intersection with every spheres\n            float dist = 10000.0;\n            vec2 dc0 = box_hit(ro, rd, cmin0, cmax0);\n            float d0 = sphere_hit(ro, rd,sc0, sr0);\n            float d1 = cylinder_hit(ro, rd, cc0, ch0, cr0, cylinder_face);\n            float d2 = y_triangle_hit(ro, rd, ty0, tv00, tv01, tv02);\n            float d3 = z_plane_hit(ro, rd, pz);\n            float d4 = y_plane_hit(ro, rd, py);\n\n            vec3 normal;\n            vec3 diffuse;\n\n            if (dc0.x > 0. && dc0.x < dc0.y && dist > dc0.x) dist = dc0.x;\n            if (dist > d0) dist = d0;\n            if (d1 > 0. && dist > d1) dist = d1;\n            if (d2 > 0. && dist > d2) dist = d2;\n            if (d3 > 0. && dist > d3) dist = d3;\n            if (d4 > 0. && dist > d4) dist = d4;\n\n            vec3 hit = ro + dist * rd;\n\n            if (dist == 10000.0) {\n              break;\n            // if any sphere is hit, accumulate the color on the sphere,\n            // and find a randomly scattered ray from the hit point as new ray\n            // for the next loop of path tracing\n            } else if (dist == dc0.x) {\n              diffuse = cd0;\n              normal = box_normal(hit, cmin0, cmax0);\n            } else if (dist == d0) {\n              diffuse = sd0;\n              normal = (hit - sc0) / sr0;\n            } else if (dist == d1) {\n              diffuse = sd0;\n              if (cylinder_face == 0) {\n                vec3 n = (hit - vec3(cc0.x, 0., cc0.z)) / cr0;\n                normal = vec3(n.x, 0., n.z);\n              } else if (cylinder_face == 1) {\n                normal = vec3(0,1,0);\n              } else {\n                normal = vec3(0,-1,0);\n              }\n            } else if (dist == d2) {\n              diffuse = sd0;\n              normal = vec3(0,1,0);\n            } else if (dist == d3) {\n              diffuse = pzd;\n              normal = vec3(0.,0.,-1.);\n            } else if (dist == d4) {\n              diffuse = pyd;\n              normal = vec3(0.,1.,0.);\n            }\n\n            if (dist == d3 || dist == d4) {\n              rd = cosineWeightedDirection(u_time, normal);\n            } else {\n              rd = customWeightedDirection(u_time, reflect(rd, normal));\n            }\n            ro = hit + 0.0001 * normal;\n\n            color_mask *= diffuse;\n            accu_color *= calc_color(hit, normal, color_mask);\n          }\n          return vec4(accu_color, 1.);\n        }\n\n        const float screen_dist = 6.;\n\n        void main() {\n          // s,t is the x,y axis of the screen-space coordinate,\n          // first assuming that there is a screen that lies in the world-space with its center at (0,0,0)\n          // and the plane of screen is parallel to the xy plane\n          vec4 st = vec4(vPosition.xy, 0., 1.);\n          st.y = -st.y;\n\n          // then, convert the screen to world-space where a camera position and direction is determined\n          // this is done by an inverse matrix operation of gluLookAt\n          // first change the basis, then translate to the world-space\n\n          vec4 rd = u_screen_to_world * st;\n          vec4 result = trace(u_camera_pos, rd.xyz);\n          \n          // gamma correction\n          result = sqrt(result);\n          // progressive rendering, where the results is accumulated with previous frame render result\n          // u_sw is a value that approximates 1\n          // thus the new frame will contribute less to the final image as time elapses\n          vec3 prev = texture2D(tex, gl_FragCoord.xy/512.0).rgb;\n          gl_FragColor = vec4(mix(result.rgb, prev, u_sw), 1.);\n        }\n      "),i=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,i);var a=new Float32Array(o);r.bufferData(r.ARRAY_BUFFER,a,r.STATIC_DRAW),r.vertexAttribPointer(0,2,r.FLOAT,!1,8,0),r.enableVertexAttribArray(0),r.bindAttribLocation(n,0,"aPosition");for(var s=[],h=0;h<2;h++)s.push(r.createTexture()),r.bindTexture(r.TEXTURE_2D,s[h]),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texImage2D(r.TEXTURE_2D,0,r.RGB,this.w,this.h,0,r.RGB,r.UNSIGNED_BYTE,null);var d=r.createFramebuffer();r.useProgram(n);var l=0,m=0,f=this;function u(e){e||(e=0),e*=.05;var t=e-m;m=e,r.clearColor(0,0,0,0),r.bindBuffer(r.ARRAY_BUFFER,i),l+=t,f.sampleCount++;var a=r.getUniformLocation(n,"u_time");r.uniform1f(a,l);var o=r.getUniformLocation(n,"u_sw");r.uniform1f(o,f.sampleCount/(f.sampleCount+1));var c=r.getUniformLocation(n,"u_camera_pos");r.uniform3f(c,f.cameraPos.x,f.cameraPos.y,f.cameraPos.z);var h=f.getScreenToWorldMatrix(),v=r.getUniformLocation(n,"u_screen_to_world");r.uniformMatrix4fv(v,!1,h),r.bindTexture(r.TEXTURE_2D,s[0]),r.bindFramebuffer(r.FRAMEBUFFER,d),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,s[1],0),r.drawArrays(r.TRIANGLE_STRIP,0,4),r.bindFramebuffer(r.FRAMEBUFFER,null),s.reverse(),r.drawArrays(r.TRIANGLE_STRIP,0,4),window.requestAnimationFrame(function(e){return u(e)})}window.requestAnimationFrame(function(e){return u(e)})},methods:{showHowToPlay:function(){"free"===this.cameraMode?alert("\n      How to play on PC or Mac\n        1. move mouse inside to look around\n        2. use WSAD key to walk around\n\n      How to play on mobile devices\n        1. touch and move inside to look around\n        2. use two-finger gesture inside to walk around\n        "):alert("\n      How to play on PC or Mac\n        1. move mouse inside to rotate camera around the origin\n\n      How to play on mobile devices\n        1. touch inside to rotate camera around the origin\n        ")},getScreenToWorldMatrix:function(){var e=[this.cameraDir.x,this.cameraDir.y,this.cameraDir.z],t=[0,1,0],r=this.crossProduct(e[0],e[1],e[2],t[0],t[1],t[2]);r=this.normalize.apply(this,Object(a["a"])(r));var n=this.crossProduct(e[0],e[1],e[2],r[0],r[1],r[2]),i=new Float32Array([r[0],r[1],r[2],0,n[0],n[1],n[2],0,e[0],e[1],e[2],0,this.screenDist*e[0],this.screenDist*e[1],this.screenDist*e[2],1]);return i},normalize:function(e,t,r){var n=Math.sqrt(e*e+t*t+r*r);return[e/n,t/n,r/n]},crossProduct:function(e,t,r,n,i,a){return[t*a-r*i,r*n-e*a,e*i-t*n]},degToRad:function(e){return 3.14159*e/180},handleLeftRight:function(e){var t=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=e*t[0],this.cameraPos.y-=e*t[1],this.cameraPos.z-=e*t[2]},handleForwardBackward:function(e){this.cameraPos.x+=e*this.cameraDir.x,this.cameraPos.y+=e*this.cameraDir.y,this.cameraPos.z+=e*this.cameraDir.z},handleKeyPress:function(e){var t=e.key,r=.1;if("w"===t)this.sampleCount=0,"free"===this.cameraMode&&(this.cameraPos.x+=r*this.cameraDir.x,this.cameraPos.y+=r*this.cameraDir.y,this.cameraPos.z+=r*this.cameraDir.z,this.screenOrigin.x=this.cameraPos.x+this.screenDist*this.cameraDir.x,this.screenOrigin.y=this.cameraPos.y+this.screenDist*this.cameraDir.y,this.screenOrigin.z=this.cameraPos.z+this.screenDist*this.cameraDir.z);else if("s"===t)this.sampleCount=0,"free"===this.cameraMode&&(this.cameraPos.x-=r*this.cameraDir.x,this.cameraPos.y-=r*this.cameraDir.y,this.cameraPos.z-=r*this.cameraDir.z,this.screenOrigin.x=this.cameraPos.x+this.screenDist*this.cameraDir.x,this.screenOrigin.y=this.cameraPos.y+this.screenDist*this.cameraDir.y,this.screenOrigin.z=this.cameraPos.z+this.screenDist*this.cameraDir.z);else if("a"===t){if("free"===this.cameraMode){this.sampleCount=0;var n=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=r*n[0],this.cameraPos.y-=r*n[1],this.cameraPos.z-=r*n[2],this.screenOrigin.x=this.cameraPos.x+this.screenDist*this.cameraDir.x,this.screenOrigin.y=this.cameraPos.y+this.screenDist*this.cameraDir.y,this.screenOrigin.z=this.cameraPos.z+this.screenDist*this.cameraDir.z}}else if("d"===t){if("free"===this.cameraMode){this.sampleCount=0;var i=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x+=r*i[0],this.cameraPos.y+=r*i[1],this.cameraPos.z+=r*i[2],this.screenOrigin.x=this.cameraPos.x+this.screenDist*this.cameraDir.x,this.screenOrigin.y=this.cameraPos.y+this.screenDist*this.cameraDir.y,this.screenOrigin.z=this.cameraPos.z+this.screenDist*this.cameraDir.z}}else"f"===t&&("free"===this.cameraMode?this.cameraMode="focus":this.cameraMode="free")},handleMouseMove:function(e){e.preventDefault(),this.sampleCount=0;var t=(e.clientX-this.canvas.left)/this.w-.5,r=(e.clientY-this.canvas.top)/this.h-.5;r=-r,t*=360,t=this.degToRad(t),r*=180,r=this.degToRad(r),this.cameraDir.pitch=r,this.cameraDir.yaw=t,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw),"focus"===this.cameraMode?(this.cameraPos.x=this.screenOrigin.x-this.screenDist*this.cameraDir.x,this.cameraPos.y=this.screenOrigin.y-this.screenDist*this.cameraDir.y,this.cameraPos.z=this.screenOrigin.z-this.screenDist*this.cameraDir.z):(this.screenOrigin.x=this.cameraPos.x+this.screenDist*this.cameraDir.x,this.screenOrigin.y=this.cameraPos.y+this.screenDist*this.cameraDir.y,this.screenOrigin.z=this.cameraPos.z+this.screenDist*this.cameraDir.z)},handleTouchMove:function(e){e.preventDefault(),this.sampleCount=0;var t=(e.touches[0].clientX-this.canvas.left)/this.w-.5,r=(e.touches[0].clientY-this.canvas.top)/this.h-.5;r=-r,"free"===this.cameraMode?2===e.touches.length?(this.handleLeftRight(-.05*t),this.handleForwardBackward(.05*r)):(t*=360,t=this.degToRad(t),r*=180,r=this.degToRad(r),this.cameraDir.pitch+=.002*r,this.cameraDir.yaw+=.002*t,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw)):(this.cameraDir.pitch+=.02*r,this.cameraDir.yaw+=.02*t,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw),this.cameraPos.x=this.screenOrigin.x-this.screenDist*this.cameraDir.x,this.cameraPos.y=this.screenOrigin.y-this.screenDist*this.cameraDir.y,this.cameraPos.z=this.screenOrigin.z-this.screenDist*this.cameraDir.z)}}},h=s,d=(r("e5cd"),r("09fd")),l=Object(d["a"])(h,n,i,!1,null,null,null);t["a"]=l.exports},e5cd:function(e,t,r){"use strict";var n=r("5b61"),i=r.n(n);i.a}});
//# sourceMappingURL=app.87b0c739.js.map