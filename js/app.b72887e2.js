(function(e){function t(t){for(var r,o,s=t[0],c=t[1],h=t[2],d=0,f=[];d<s.length;d++)o=s[d],a[o]&&f.push(a[o][0]),a[o]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(e[r]=c[r]);l&&l(t);while(f.length)f.shift()();return i.push.apply(i,h||[]),n()}function n(){for(var e,t=0;t<i.length;t++){for(var n=i[t],r=!0,s=1;s<n.length;s++){var c=n[s];0!==a[c]&&(r=!1)}r&&(i.splice(t--,1),e=o(o.s=n[0]))}return e}var r={},a={app:0},i=[];function o(t){if(r[t])return r[t].exports;var n=r[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=e,o.c=r,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)o.d(n,r,function(t){return e[t]}.bind(null,r));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var h=0;h<s.length;h++)t(s[h]);var l=c;i.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("4188")},"5b61":function(e,t,n){},bcd5:function(e,t,n){"use strict";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("canvas",{attrs:{id:"cvs",width:e.w,height:e.h},on:{touchstart:function(e){e.preventDefault()},touchmove:e.handleTouchMove,mousemove:e.handleMouseMove}}),n("h2",[e._v("A demo for movable camera and path tracing")]),n("p",[e._v("How to play on PC or Mac")]),e._m(0),n("p",[e._v("How to play on mobile devices")]),e._m(1)])},a=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("move mouse inside to look around")]),n("li",[e._v("use WSAD key to walk around")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",[n("li",[e._v("touch and move inside to look around")]),n("li",[e._v("use two-finger gesture inside to walk around")])])}],i=n("90a7"),o=(n("4081"),[-1,-1,1,-1,-1,1,1,1]);function s(e,t,n){var r=t,a=n,i=e.createShader(e.VERTEX_SHADER);if(e.shaderSource(i,r),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS))return console.error("An error occurred compiling the vertex shaders: "+e.getShaderInfoLog(i)),e.deleteShader(i),null;var o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,a),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))return console.error("An error occurred compiling the fragment shaders: "+e.getShaderInfoLog(o)),e.deleteShader(o),null;var s=e.createProgram();return e.attachShader(s,i),e.attachShader(s,o),e.linkProgram(s),s}var c={data:function(){return{w:512,h:512,mouse:{x:0,y:0},canvas:{left:0,top:0},cameraPos:{x:0,y:0,z:6},cameraDir:{yaw:0,pitch:0,x:0,y:0,z:-1},sampleCount:0}},mounted:function(){var e=this,t=document.querySelector("canvas").getBoundingClientRect();this.canvas.left=t.left,this.canvas.top=t.top,document.addEventListener("keypress",function(t){e.handleKeyPress(t)});var n=document.querySelector("#cvs").getContext("webgl"),r=s(n,"\n        attribute vec4 aPosition;\n        varying vec4 vPosition;\n\n        void main() {\n          vPosition = aPosition;\n          gl_Position = aPosition;\n        }\n      ","\n        precision highp float;\n        uniform vec3 u_camera_pos;\n        varying vec4 vPosition;\n        uniform float u_time;\n        uniform float u_sw;\n        uniform mat4 u_screen_to_world;\n        uniform sampler2D tex;\n\n        // cube min vertx\n        const vec3 cmin0 = vec3(-0.2,-1.0,-1.);\n        // cube max vertx\n        const vec3 cmax0 = vec3(0.2,-0.6,-0.6);\n        // cube diffuse color\n        const vec3 cd0 = vec3(0.52);\n\n        // sphere center\n        const vec3 sc0 = vec3(-0.8,-0.5,-4.);\n        // sphere radius\n        const float sr0 = 0.5;\n        // sphere diffuse color\n        const vec3 sd0 = vec3(1.,0.3,0.3);\n\n        const vec3 sc1 = vec3(0.8,-0.5,-4.);\n        const float sr1 = 0.5;\n        const vec3 sd1 = vec3(0.84,0.55,0.15);\n\n\n        const vec3 sc2 = vec3(0.0,-0.7,-3.);\n        const float sr2 = 0.3;\n        const vec3 sd2 = vec3(1.,1.,1.);\n\n\n        // sky (a big sphere at the back of the scene)\n        const vec3 sc3 = vec3(0.,-0.5,-115.4);\n        const float sr3 = 100.0;\n        const vec3 sd3 = vec3(0.2,0.4,0.4);\n\n\n        // ground (a big sphere at the bottom of the scene)\n        const vec3 sc4 = vec3(0.,-101.,-4.);\n        const float sr4 = 100.0;\n        const vec3 sd4 = vec3(0.3,0.2,0.1);\n\n\n        float random(vec2 scale, float seed) {\n          return fract(sin(dot(gl_FragCoord.xy + seed, scale)) * 43758.5453);\n        }\n\n        vec3 cosineWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float r = sqrt(1. - v);\n          float x = r * cos(theta);\n          float y = sqrt(v);\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = cross(right, normal);\n          return right * x + normal * y + front * z;\n        }\n\n        vec3 customWeightedDirection(float seed, vec3 normal) {\n          float u = random(vec2(12.9898, 78.233), seed);\n          float v = random(vec2(63.7264, 10.873), seed);\n\n          float theta = 6.28 * u;\n          float k = pow(v, 0.0001);\n          float r = sqrt(1. - k*k);\n          float x = r * cos(theta);\n          float y = k;\n          float z = r * sin(theta);\n\n          vec3 right = normalize(cross(normal, vec3(0.1)));\n          vec3 front = cross(right, normal);\n          return right * x + normal * y + front * z;\n        }\n\n        // the function for ray-sphere intersection, given the origin and direction of a ray and the center and radius of a sphere\n        // returns the minimal distance when the ray hits the surface of the sphere\n        // when no intersection, returns 10000.0 \n        float sphere_hit(vec3 ro, vec3 rd, vec3 center, float r) {\n          vec3 oc = ro - center;\n          float a = dot(rd, rd);\n          float b = 2.0 * dot(oc, rd);\n          float c = dot(oc, oc) - r * r;\n          float discriminant = b * b - 4.0 * a * c;\n          if (discriminant > 0.0) {\n            float temp = (- b - sqrt(discriminant)) / (2.0 * a);\n            if (temp > 0.) {\n              return temp;\n            }\n          }\n          return 10000.0;\n        }\n\n        // the function for axis-aligned ray-box intersection\n        vec2 box_hit(vec3 ro, vec3 rd, vec3 box_min, vec3 box_max) {\n          vec3 tmin = (box_min - ro) / rd;\n          vec3 tmax = (box_max - ro) / rd;\n\n          vec3 t1 = min(tmin, tmax);\n          vec3 t2 = max(tmin, tmax);\n\n          float tnear = max(max(t1.x, t1.y), t1.z);\n          float tfar = min(min(t2.x, t2.y), t2.z);\n\n          return vec2(tnear, tfar);\n        }\n\n        // the function for resolving color on a specific hit point\n        // currently returns only the diffuse color\n        vec3 calc_color(vec3 hit, vec3 normal, vec3 diff_c) {\n          vec3 light = vec3(2.8,2.5,1.5);\n          vec3 l = normalize(light - hit);\n          float diff = dot(l, normal);\n\n          vec3 v = normalize(u_camera_pos - hit);\n          float spec = dot(v, reflect(-l, normal));\n          return pow(max(diff, 0.), 4.) + pow(max(spec,0.), 32.) + diff_c;\n        }\n\n        vec3 refr(vec3 ray, vec3 normal, float ri) {\n          float dt = dot(ray, normal);\n          float ni_over_nt;\n          vec3 n;\n          if (dt > 0.) {\n            n = -normal;\n            ni_over_nt = ri;\n          } else {\n            n = normal;\n            ni_over_nt = 1./ri;\n          }\n\n          float discriminant = 1. - ni_over_nt*ni_over_nt*(1. - dt*dt);\n          if (discriminant > 0.) {\n            return ri*(ray - n*dt)-n*sqrt(discriminant);\n          } else {\n            return reflect(ray, normal);\n          }\n        }\n\n        vec3 box_normal(vec3 hit, vec3 box_min, vec3 box_max) {\n          if (hit.x < box_min.x + 0.001) return vec3(-1,0,0);\n          else if (hit.x > box_max.x - 0.001) return vec3(1,0,0);\n\n          else if (hit.y < box_min.y + 0.001) return vec3(0,-1,0);\n          else if (hit.y > box_max.y - 0.001) return vec3(0,1,0);\n\n          else if (hit.z < box_min.z + 0.001) return vec3(0,0,-1);\n          return vec3(0,0,1);\n        }\n\n        vec4 trace(vec3 ro, vec3 rd) {\n          vec3 color_mask = vec3(1.);\n          vec3 accu_color = vec3(1.);\n\n          // the path tracing depth\n          for (int i = 0; i < 5; i++) {\n            // finding the nearest hit point by checking intersection with every spheres\n            float dist = 10000.0;\n            vec2 dc0 = box_hit(ro, rd, cmin0, cmax0);\n            float d0 = sphere_hit(ro, rd,sc0, sr0);\n            float d1 = sphere_hit(ro, rd,sc1, sr1);\n            float d2 = sphere_hit(ro, rd,sc2, sr2);\n            float d3 = sphere_hit(ro, rd,sc3, sr3);\n            float d4 = sphere_hit(ro, rd,sc4, sr4);\n\n            vec3 normal;\n            vec3 diffuse;\n\n            if (dc0.x > 0. && dc0.x < dc0.y && dist > dc0.x) dist = dc0.x;\n            if (dist > d0) dist = d0;\n            if (dist > d1) dist = d1;\n            if (dist > d2) dist = d2;\n            if (dist > d3) dist = d3;\n            if (dist > d4) dist = d4;\n\n            vec3 hit = ro + dist * rd;\n\n            if (dist == 10000.0) {\n              break;\n            // if any sphere is hit, accumulate the color on the sphere,\n            // and find a randomly scattered ray from the hit point as new ray\n            // for the next loop of path tracing\n            } else if (dist == dc0.x) {\n              diffuse = cd0;\n              normal = box_normal(hit, cmin0, cmax0);\n            } else if (dist == d0) {\n              diffuse = sd0;\n              normal = (hit - sc0) / sr0;\n            } else if (dist == d1) {\n              diffuse = sd1;\n              normal = (hit - sc1) / sr1;\n            } else if (dist == d2) {\n              diffuse = sd2;\n              normal = (hit - sc2) / sr2;\n            } else if (dist == d3) {\n              diffuse = sd3;\n              normal = (hit - sc3) / sr3;\n            } else if (dist == d4) {\n              diffuse = sd4;\n              normal = (hit - sc4) / sr4;\n            }\n\n            if (dist == dc0.x) {\n              rd = customWeightedDirection(u_time, refr(rd, normal, 1.2));\n            } else if (dist == d0) {\n              rd = customWeightedDirection(u_time, reflect(rd, normal));\n            } else {\n              rd = cosineWeightedDirection(u_time, normal);\n            }\n\n            color_mask *= diffuse;\n            accu_color *= calc_color(hit, normal, color_mask);\n            ro = hit - 0.0001 * normal;\n          }\n          return vec4(accu_color, 1.);\n        }\n\n        const float screen_dist = 6.;\n\n        void main() {\n          // s,t is the x,y axis of the screen-space coordinate,\n          // first assuming that there is a screen that lies in the world-space with its center at (0,0,0)\n          // and the plane of screen is parallel to the xy plane\n          vec4 st = vec4(vPosition.xy, 0., 1.);\n          st.y = -st.y;\n\n          // then, convert the screen to world-space where a camera position and direction is determined\n          // this is done by an inverse matrix operation of gluLookAt\n          // first change the basis, then translate to the world-space\n\n          vec4 rd = u_screen_to_world * st;\n          vec4 result = trace(u_camera_pos, rd.xyz);\n          \n          // gamma correction\n          result = sqrt(result);\n          // progressive rendering, where the results is accumulated with previous frame render result\n          // u_sw is a value that approximates 1\n          // thus the new frame will contribute less to the final image as time elapses\n          vec3 prev = texture2D(tex, gl_FragCoord.xy/512.0).rgb;\n          gl_FragColor = vec4(mix(result.rgb, prev, u_sw), 1.);\n        }\n      "),a=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,a);var i=new Float32Array(o);n.bufferData(n.ARRAY_BUFFER,i,n.STATIC_DRAW),n.vertexAttribPointer(0,2,n.FLOAT,!1,8,0),n.enableVertexAttribArray(0),n.bindAttribLocation(r,0,"aPosition");for(var c=[],h=0;h<2;h++)c.push(n.createTexture()),n.bindTexture(n.TEXTURE_2D,c[h]),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texImage2D(n.TEXTURE_2D,0,n.RGB,this.w,this.h,0,n.RGB,n.UNSIGNED_BYTE,null);var l=n.createFramebuffer();n.useProgram(r);var d=0,f=0,m=this;function u(e){e||(e=0),e*=.05;var t=e-f;f=e,n.clearColor(0,0,0,0),n.bindBuffer(n.ARRAY_BUFFER,a),d+=t,m.sampleCount++;var i=n.getUniformLocation(r,"u_time");n.uniform1f(i,d);var o=n.getUniformLocation(r,"u_sw");n.uniform1f(o,m.sampleCount/(m.sampleCount+1));var s=n.getUniformLocation(r,"u_camera_pos");n.uniform3f(s,m.cameraPos.x,m.cameraPos.y,m.cameraPos.z);var h=m.getScreenToWorldMatrix(),v=n.getUniformLocation(r,"u_screen_to_world");n.uniformMatrix4fv(v,!1,h),n.bindTexture(n.TEXTURE_2D,c[0]),n.bindFramebuffer(n.FRAMEBUFFER,l),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,c[1],0),n.drawArrays(n.TRIANGLE_STRIP,0,4),n.bindFramebuffer(n.FRAMEBUFFER,null),c.reverse(),n.drawArrays(n.TRIANGLE_STRIP,0,4),window.requestAnimationFrame(function(e){return u(e)})}window.requestAnimationFrame(function(e){return u(e)})},methods:{getScreenToWorldMatrix:function(){var e=6,t=[this.cameraDir.x,this.cameraDir.y,this.cameraDir.z],n=[0,1,0],r=this.crossProduct(t[0],t[1],t[2],n[0],n[1],n[2]);r=this.normalize.apply(this,Object(i["a"])(r));var a=this.crossProduct(t[0],t[1],t[2],r[0],r[1],r[2]),o=new Float32Array([r[0],r[1],r[2],0,a[0],a[1],a[2],0,t[0],t[1],t[2],0,e*t[0],e*t[1],e*t[2],1]);return o},normalize:function(e,t,n){var r=Math.sqrt(e*e+t*t+n*n);return[e/r,t/r,n/r]},crossProduct:function(e,t,n,r,a,i){return[t*i-n*a,n*r-e*i,e*a-t*r]},degToRad:function(e){return 3.14159*e/180},handleLeftRight:function(e){var t=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=e*t[0],this.cameraPos.y-=e*t[1],this.cameraPos.z-=e*t[2]},handleForwardBackward:function(e){this.cameraPos.x+=e*this.cameraDir.x,this.cameraPos.y+=e*this.cameraDir.y,this.cameraPos.z+=e*this.cameraDir.z},handleKeyPress:function(e){this.sampleCount=0;var t=e.key,n=.1;if("w"===t)this.cameraPos.x+=n*this.cameraDir.x,this.cameraPos.y+=n*this.cameraDir.y,this.cameraPos.z+=n*this.cameraDir.z;else if("s"===t)this.cameraPos.x-=n*this.cameraDir.x,this.cameraPos.y-=n*this.cameraDir.y,this.cameraPos.z-=n*this.cameraDir.z;else if("a"===t){var r=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x-=n*r[0],this.cameraPos.y-=n*r[1],this.cameraPos.z-=n*r[2]}else if("d"===t){var a=this.crossProduct(this.cameraDir.x,this.cameraDir.y,this.cameraDir.z,0,1,0);this.cameraPos.x+=n*a[0],this.cameraPos.y+=n*a[1],this.cameraPos.z+=n*a[2]}},handleMouseMove:function(e){e.preventDefault(),this.sampleCount=0;var t=(e.clientX-this.canvas.left)/this.w-.5,n=(e.clientY-this.canvas.top)/this.h-.5;n=-n,t*=360,t=this.degToRad(t),n*=180,n=this.degToRad(n),this.cameraDir.pitch=n,this.cameraDir.yaw=t,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw)},handleTouchMove:function(e){e.preventDefault(),this.sampleCount=0;var t=(e.touches[0].clientX-this.canvas.left)/this.w-.5,n=(e.touches[0].clientY-this.canvas.top)/this.h-.5;n=-n,2===e.touches.length?(this.handleLeftRight(-.05*t),this.handleForwardBackward(.05*n)):(t*=360,t=this.degToRad(t),n*=180,n=this.degToRad(n),this.cameraDir.pitch+=.002*n,this.cameraDir.yaw+=.002*t,this.cameraDir.z=-Math.cos(this.cameraDir.pitch)*Math.cos(this.cameraDir.yaw),this.cameraDir.y=Math.sin(this.cameraDir.pitch),this.cameraDir.x=Math.cos(this.cameraDir.pitch)*Math.sin(this.cameraDir.yaw))}}},h=c,l=(n("e5cd"),n("09fd")),d=Object(l["a"])(h,r,a,!1,null,null,null);t["a"]=d.exports},e5cd:function(e,t,n){"use strict";var r=n("5b61"),a=n.n(r);a.a}});
//# sourceMappingURL=app.b72887e2.js.map